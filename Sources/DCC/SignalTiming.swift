//
//  SignalTiming.swift
//  DCC
//
//  Created by Scott James Remnant on 5/19/18.
//

/// A type that calculates timings of pulses for DCC bits.
///
/// Handles the conversion from logical bits to the required number of physical pulses generated by
/// PWM or GPIO hardware.
///
/// `SignalTiming` is initialized with a `pulseWidth` giving the duration in microseconds of the
/// smallest pulse that the hardware can generated, generally derived from its clock.
///
/// The properties of the instance can then be used to retrieve the length of a pulse, in multiples
/// of the given width, required to send a zero bit or one bit, as well as the timing of any
/// RailCom cutout.
public struct SignalTiming {
    /// Recommended duration in microseconds of the high and low parts of a one bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the nominal duration for a one bit.
    public static let oneBit: Float = 58
    
    /// Permitted duration in microseconds of the high and low parts of a one bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the range of permitted durations for the command station to send,
    ///   while allowing decoders to be less strict.
    public static let oneBitRange: ClosedRange<Float> = 55...61
    
    /// Recommended duration in microseconds of the high and low parts of a zero bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the nominal "greater than or equal to" duration for a zero bit.
    public static let zeroBit: Float = 100
    
    /// Permitted duration in microseconds of the high and low parts of a zero bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines the minimum of permitted duration for the command station to send,
    ///   while allowing decoders to be less strict.
    ///
    ///   For the maximum it specifies that Digital Command Station components shall transmit "0"
    ///   bits with each part of the bit having a duration of between 95 and 9900 microseconds with the
    ///   total bit duration of the "0" bit not exceeding 12000 microseconds.
    ///
    ///   Since our transmission parts are always equal in length, this is half of the latter value.
    public static let zeroBitRange: ClosedRange<Float> = 95...6000
    
    /// Permitted duration in microseconds before the start of the RailCom cutout.
    ///
    /// No nominal duration is defined by the standard, so the lower bound is the target we use when
    /// calculating bit lengths.
    ///
    /// - Note:
    ///   NMRA S-9.1 specifies that the DCC signal must continue for at least 26µs after the packet
    ///   end bit, which delays the time for the start of the RailCom cutout.
    ///
    ///   NMRA S-9.3.2 specifies the maximum delay.
    public static let railComDelayRange: ClosedRange<Float> = 26...32
    
    /// Permitted duration in microseconds of the RailCom cutout.
    ///
    /// No nominal duration is defined by the standard, so the lower bound is the target we use when
    /// calculating bit lengths.
    ///
    /// - Note:
    ///   Specified in NMRA S-9.3.2 and is measured from the end of the Packet End Bit, and thus
    ///   includes the delay before the start of the RailCom cutout.
    public static let railComRange: ClosedRange<Float> = 454...488
    
    /// Minimum count in bits of a preamble.
    ///
    /// - Note:
    ///   NMRA S-9.2 requires that the preamble consist of a minimum of 14 bits, while it permits
    ///   lower values only for the decoder. For service mode programming, NMRA S-9.2.3 specifies a
    ///   long preamble of 20 bits.
    public let preambleCount: Int = 14
    
    /// Duration in microseconds of a single pulse.
    public let pulseWidth: Float
    
    /// Length in pulses of the high and low parts of a one bit.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let oneBitLength: Int
    
    /// Length in pulses of the high and low parts of a zero bit.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let zeroBitLength: Int
    
    /// Length in pulses of the delay before the start of the RailCom cutout.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let railComDelayLength: Int
    
    /// Length in pulses of the RailCom cutout.
    ///
    /// This bit length is measured from the end of the Packet End Bit, and thus includes the bits
    /// specified in `railComDelayLength`. It is calculated during initialization based on
    /// `pulseWidth`.
    public let railComLength: Int
    
    /// Count of bits for the entire RailCom output.
    ///
    /// This is the value of `railComLength` divided by the double of `oneBitLength`, thus yielding
    /// the number of complete one bits required from the end of the Packet End Bit to the start of
    /// the preamble.
    public let railComCount: Int
    
    public enum Error : Swift.Error {
        /// Thown by SignalTiming.init when it cannot produce standards conformant timings
        /// from the given `pulseWidth`.
        case conformanceError(message: String)
    }

    public init(pulseWidth: Float) throws {
        self.pulseWidth = pulseWidth

        // The nominal one bit length is exactly in the middle of the permitted
        // range, so schoolbook rounding will always pick the closest value, and
        // if it's not within the valid range, neither will any alternative be.
        let oneBitLength = (Self.oneBit / pulseWidth).rounded()
        if Self.oneBitRange.contains(oneBitLength * pulseWidth) {
            self.oneBitLength = Int(oneBitLength)
        } else {
            throw Error.conformanceError(message: "Duration of one bit would be \(oneBitLength * pulseWidth)µs which is outside the valid range \(SignalTiming.oneBitRange)µs")
        }

        // The nominal zero bit length is towards the start of a wide range; use
        // schoolbook rounding to get the closest value, but if that falls
        // outside of the range, try adding one to the result to fit it within
        // the broader high side.
        let zeroBitLength = (Self.zeroBit / pulseWidth).rounded()
        if Self.zeroBitRange.contains(zeroBitLength * pulseWidth) {
            self.zeroBitLength = Int(zeroBitLength)
        } else if Self.zeroBitRange.contains((zeroBitLength + 1) * pulseWidth) {
            self.zeroBitLength = Int(zeroBitLength + 1)
        } else {
            throw Error.conformanceError(message: "Duration of zero bit would be \(zeroBitLength * pulseWidth)µs which is outside the valid range \(SignalTiming.zeroBitRange)µs")
        }

        // Since we use the lower bound as the target, rounding away from zero
        // is always the correct approach to attempting to get a result within
        // the valid range.
        let railComDelayLength = (Self.railComDelayRange.lowerBound / pulseWidth).rounded(.awayFromZero)
        if Self.railComDelayRange.contains(railComDelayLength * pulseWidth) {
            self.railComDelayLength = Int(railComDelayLength)
        } else {
            throw Error.conformanceError(message: "Duration of pre-RailCom cutout delay would be \(railComDelayLength * pulseWidth)µs which is outside the valid range \(SignalTiming.railComDelayRange)µs")
        }

        // Since we use the lower bound as the target, rounding away from zero
        // is always the correct approach to attempting to get a result within
        // the valid range.
        let railComLength = (Self.railComRange.lowerBound / pulseWidth).rounded(.awayFromZero)
        if Self.railComRange.contains(railComLength * pulseWidth) {
            self.railComLength = Int(railComLength)
        } else {
            throw Error.conformanceError(message: "Duration of RailCom cutout would be \(railComLength * pulseWidth)µs which is outside the valid range \(SignalTiming.railComRange)µs")
        }

        railComCount = Int((railComLength / (oneBitLength * 2)).rounded(.awayFromZero))
    }
}

// MARK: Debugging

extension SignalTiming : CustomStringConvertible {
    public var description: String {
        "<\(type(of: self)) \(pulseWidth)µs, 1: \(oneBitLength), 0: \(zeroBitLength)>"
    }
}
