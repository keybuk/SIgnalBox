//
//  SignalTiming.swift
//  DCC
//
//  Created by Scott James Remnant on 5/19/18.
//

/// A type that calculates timings of pulses for DCC bits.
///
/// Handles the conversion from logical bits to the required number of physical pulses generated by
/// PWM or GPIO hardware.
///
/// `SignalTiming` is initialized with a `pulseWidth` giving the duration in microseconds of the
/// smallest pulse that the hardware can generated, generally derived from its clock.
///
/// The properties of the instance can then be used to retrieve the length of a pulse, in multiples
/// of the given width, required to send a zero bit or one bit, as well as the timing of any
/// RailCom cutout.
public struct SignalTiming {
    /// Recommended duration in microseconds of the high and low parts of a one bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the nominal duration for a one bit.
    public static let oneBit: Float = 58
    
    /// Permitted duration in microseconds of the high and low parts of a one bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the range of permitted durations for the command station to send,
    ///   while allowing decoders to be less strict.
    public static let oneBitRange: ClosedRange<Float> = 55...61
    
    /// Recommended duration in microseconds of the high and low parts of a zero bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the nominal "greater than or equal to" duration for a zero bit.
    public static let zeroBit: Float = 100
    
    /// Permitted duration in microseconds of the high and low parts of a zero bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines the minimum of permitted duration for the command station to send,
    ///   while allowing decoders to be less strict.
    ///
    ///   For the maximum it specifies that Digital Command Station components shall transmit "0"
    ///   bits with each part of the bit having a duration of between 95 and 9900 microseconds with the
    ///   total bit duration of the "0" bit not exceeding 12000 microseconds.
    ///
    ///   Since our transmission parts are always equal in length, this is half of the latter value.
    public static let zeroBitRange: ClosedRange<Float> = 95...6000
    
    /// Permitted duration in microseconds before the start of the RailCom cutout.
    ///
    /// No nomimal duration is defined by the standard, so this is the target we use when
    /// calculating bit lengths.
    ///
    /// - Note:
    ///   NMRA S-9.1 specifies that the DCC signal must continue for at least 26µs after the packet
    ///   end bit, which delays the time for the start of the RailCom cutout.
    ///
    ///   NMRA S-9.3.2 specifies the maximum delay.
    public static let railComDelayRange: ClosedRange<Float> = 26...32
    
    /// Permitted duration in microseconds of the RailCom cutout.
    ///
    /// No nomimal duration is defined by the standard, so this is the target we use when
    /// calculating bit lengths.
    ///
    /// - Note:
    ///   Specified in NMRA S-9.3.2 and is measured from the end of the Packet End Bit, and thus
    ///   includes the delay before the start of the RailCom cutout.
    public static let railComRange: ClosedRange<Float> = 454...488
    
    /// Minimum count in bits of a preamble.
    ///
    /// - Note:
    ///   NMRA S-9.2 requires that the preamble consist of a minimum of 14 bits, while it permits
    ///   lower values only for the decoder. For service mode programming, NMRA S-9.2.3 specifies a
    ///   long preamble of 20 bits.
    public static let preambleCountMin: Int = 14
    
    /// Duration in microseconds of a single pulse.
    public let pulseWidth: Float
    
    /// Length in pulses of the high and low parts of a one bit.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let oneBitLength: Int
    
    /// Length in pulses of the high and low parts of a zero bit.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let zeroBitLength: Int
    
    /// Length in pulses of the delay before the start of the RailCom cutout.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let railComDelayLength: Int
    
    /// Length in pulses of the RailCom cutout.
    ///
    /// This bit length is measured from the end of the Packet End Bit, and thus includes the bits
    /// specified in `railComDelayLength`. It is calculated during initialization based on
    /// `pulseWidth`.
    public let railComLength: Int
    
    /// Count of bits for the entire RailCom output.
    ///
    /// This is the value of `railComLength` divided by the double of `oneBitLength`, thus yielding
    /// the number of complete one bits required from the end of the Packet End Bit to the start of
    /// the preamble.
    public let railComCount: Int
    
    /// Count of bits for the preamble.
    ///
    /// This includes sufficient bits for a complete preamble, and the RailCom cutout.
    public let preambleCount: Int
    
    public enum Error : Swift.Error {
        
        /// Thown by SignalTiming.init when it cannot produce standards conformant timings
        /// from the given `pulseWidth`.
        case conformanceError(message: String)
    
    }

    public init(pulseWidth: Float) throws {
        self.pulseWidth = pulseWidth
        
        oneBitLength = Int((Self.oneBit - 1) / pulseWidth) + 1
        zeroBitLength = Int((Self.zeroBit - 1) / pulseWidth) + 1
        
        railComDelayLength = Int((Self.railComDelayRange.lowerBound - 1) / pulseWidth) + 1
        railComLength = Int((Self.railComRange.lowerBound - 1) / pulseWidth) + 1
        
        railComCount = (railComLength - 1) / (oneBitLength * 2) + 1
        
        preambleCount = Self.preambleCountMin + railComCount
        
        // Sanity check the lengths.
        guard Self.oneBitRange.contains(Float(oneBitLength) * pulseWidth) else {
                throw Error.conformanceError(message: "Duration of one bit would be \(Float(oneBitLength) * pulseWidth)µs which is outside the valid range \(SignalTiming.oneBitRange)µs")
        }
        guard Self.zeroBitRange.contains(Float(zeroBitLength) * pulseWidth) else {
                throw Error.conformanceError(message: "Duration of zero bit would be \(Float(zeroBitLength) * pulseWidth)µs which is outside the valid range \(SignalTiming.zeroBitRange)µs")
        }
        guard Self.railComDelayRange.contains(Float(railComDelayLength) * pulseWidth) else {
                throw Error.conformanceError(message: "Duration of pre-RailCom cutout delay would be \(Float(railComDelayLength) * pulseWidth)µs which is outside the valid range \(SignalTiming.railComDelayRange)µs")
        }
        guard Self.railComRange.contains(Float(railComLength) * pulseWidth) else {
                throw Error.conformanceError(message: "Duration of RailCom cutout would be \(Float(railComLength) * pulseWidth)µs which is outside the valid range \(SignalTiming.railComRange)µs")
        }
    }
}

// MARK: Debugging

extension SignalTiming : CustomDebugStringConvertible {
    public var debugDescription: String {
        return "<\(type(of: self)) \(pulseWidth)µs, 1: \(oneBitLength), 0: \(zeroBitLength)>"
    }
}
