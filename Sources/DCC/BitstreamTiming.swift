//
//  BitstreamTiming.swift
//  DCC
//
//  Created by Scott James Remnant on 5/19/18.
//

import Foundation

/// A type that calculates timings of pulses for DCC bits.
///
/// Handles the conversion from logical bits to the required number of physical pulses generated by
/// PWM or GPIO hardware.
///
/// `BitstreamTiming` is initialized with a `pulseWidth` giving the duration in microseconds of the
/// smallest pulse that the hardware can generated, generally derived from its clock.
///
/// The properties of the instance can then be used to retrieve the length of a pulse, in multiples
/// of the given width, required to send a zero bit or one bit, as well as the timing of any
/// RailCom cutout.
public struct BitstreamTiming {

    /// Recommended duration in microseconds of the high and low parts of a one bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the nominal duration for a one bit.
    public static let oneBit: Float = 58
    
    /// Minimum permitted duration in microseconds of the high and low parts of a one bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the minimum permitted duration for the command station to send,
    ///   while allowing decoders to be less strict.
    public static let oneBitMin: Float = 55
    
    /// Maximum permitted duration in microseconds of the high and low parts of a one bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the maximum permitted duration for the command station to send,
    ///   while allowing decoders to be less strict.
    public static let oneBitMax: Float = 61
    
    /// Recommended duration in microseconds of the high and low parts of a zero bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the nominal "greater than or equal to" duration for a zero bit.
    public static let zeroBit: Float = 100
    
    /// Minimum permitted duration in microseconds of the high and low parts of a zero bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 defines this as the minimum permitted duration for the command station to send,
    ///   while allowing decoders to be less strict.
    public static let zeroBitMin: Float = 95
    
    /// Maximum permitted duration in microseconds of the high and low parts of a zero bit.
    ///
    /// - Note:
    ///   NMRA S-9.1 specifies: Digital Command Station components shall transmit "0" bits with each
    ///   part of the bit having a duration of between 95 and 9900 microseconds with the total bit
    ///   duration of the "0" bit not exceeding 12000 microseconds.
    ///
    ///   Since our transmission parts are always equal in length, this is half of the latter value.
    public static let zeroBitMax: Float = 6000
    
    /// Minimum permitted duration in microseconds before the start of the RailCom cutout.
    ///
    /// No nomimal duration is defined by the standard, so this is the target we use when
    /// calculating bit lengths.
    ///
    /// - Note:
    ///   NMRA S-9.1 specifies that the DCC signal must continue for at least 26µs after the packet
    ///   end bit, which delays the time for the start of the RailCom cutout.
    public static let railComDelayMin: Float = 26
    
    /// Maximum permitted duration in microseconds before the start of the RailCom cutout.
    ///
    /// - Note:
    ///   Specified in NMRA S-9.3.2.
    public static let railComDelayMax: Float = 32
    
    /// Minimum permitted duration in microseconds of the RailCom cutout.
    ///
    /// No nomimal duration is defined by the standard, so this is the target we use when
    /// calculating bit lengths.
    ///
    /// - Note:
    ///   Specified in NMRA S-9.3.2 and is measured from the end of the Packet End Bit, and thus
    ///   includes the delay before the start of the RailCom cutout.
    public static let railComMin: Float = 454
    
    /// Maximum permitted duration in microseconds of the RailCom cutout.
    ///
    /// - Note:
    ///   Specified in NMRA S-9.3.2 and is measured from the end of the Packet End Bit, and thus
    ///   includes the delay before the start of the RailCom cutout.
    public static let railComMax: Float = 488
    
    /// Duration in microseconds of a single pulse.
    public let pulseWidth: Float
    
    /// Length in pulses of the high and low parts of a one bit.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let oneBitLength: Int
    
    /// Length in pulses of the high and low parts of a zero bit.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let zeroBitLength: Int
    
    /// Length in pulses of the delay before the start of the RailCom cutout.
    ///
    /// This is calculated during initialization based on `pulseWidth`.
    public let railComDelayLength: Int
    
    /// Length in pulses of the RailCom cutout.
    ///
    /// This bit length is measured from the end of the Packet End Bit, and thus includes the bits
    /// specified in `railComDelayLength`. It is calculated during initialization based on
    /// `pulseWidth`.
    public let railComCutoutLength: Int
    
    /// Length in pulses of the entire RailCom output.
    ///
    /// This is the value of `railComCutoutLength` rounded up to the nearest double of
    /// `oneBitLength`, thus allowing for the complete transmission of logical one bits by the end
    /// of the RailCom output period.
    public let railComLength: Int
    
    public enum Error : Swift.Error {
        
        /// Thown by BitstreamTiming.init when it cannot produce standards conformant timings
        /// from the given `pulseWidth`.
        case conformanceError(message: String)
    
    }

    public init(pulseWidth: Float) throws {
        self.pulseWidth = pulseWidth
        
        oneBitLength = Int((BitstreamTiming.oneBit - 1.0) / pulseWidth) + 1
        zeroBitLength = Int((BitstreamTiming.zeroBit - 1.0) / pulseWidth) + 1
        
        railComDelayLength = Int((BitstreamTiming.railComDelayMin - 1.0) / pulseWidth) + 1
        railComCutoutLength = Int((BitstreamTiming.railComMin - 1.0) / pulseWidth) + 1
        
        railComLength = (oneBitLength * 2) * ((railComCutoutLength - 1) / (oneBitLength * 2) + 1)
        
        // Sanity check the lengths.
        guard ((Float(oneBitLength) * pulseWidth) >= BitstreamTiming.oneBitMin) &&
            ((Float(oneBitLength) * pulseWidth) <= BitstreamTiming.oneBitMax) else {
                throw Error.conformanceError(message: "Duration of one bit would be \(Float(oneBitLength) * pulseWidth)µs which is outside the valid range \(BitstreamTiming.oneBitMin)–\(BitstreamTiming.oneBitMax)µs")
        }
        guard ((Float(zeroBitLength) * pulseWidth) >= BitstreamTiming.zeroBitMin) &&
            ((Float(zeroBitLength) * pulseWidth) <= BitstreamTiming.zeroBitMax) else {
                throw Error.conformanceError(message: "Duration of zero bit would be \(Float(zeroBitLength) * pulseWidth)µs which is outside the valid range \(BitstreamTiming.zeroBitMin)–\(BitstreamTiming.zeroBitMax)µs")
        }
        guard ((Float(railComDelayLength) * pulseWidth) >= BitstreamTiming.railComDelayMin) &&
            ((Float(railComDelayLength) * pulseWidth) <= BitstreamTiming.railComDelayMax) else {
                throw Error.conformanceError(message: "Duration of pre-RailCom cutout delay would be \(Float(railComDelayLength) * pulseWidth)µs which is outside the valid range \(BitstreamTiming.railComDelayMin)–\(BitstreamTiming.railComDelayMax)µs")
        }
        guard ((Float(railComCutoutLength) * pulseWidth) >= BitstreamTiming.railComMin) &&
            ((Float(railComCutoutLength) * pulseWidth) <= BitstreamTiming.railComMax) else {
                throw Error.conformanceError(message: "Duration of RailCom cutout would be \(Float(railComCutoutLength) * pulseWidth)µs which is outside the valid range \(BitstreamTiming.railComMin)–\(BitstreamTiming.railComMax)µs")
        }
    }

}
